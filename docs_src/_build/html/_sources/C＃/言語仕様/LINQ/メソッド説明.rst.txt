============
メソッド説明
============

LINQのメソッドリスト
====================

.. glossary::

  Aggregate

    * aa

  All

    * aa

  Any

    * aa

  AsEnumerable

    * aa

  AsOrdered

    * aa

  AsParallel

    * クエリの並列化を有効にする
    * クエリのソースにこのメソッドを追加するだけで並列処理される
    * 順番に依存する処理での使用は要注意

      .. code-block:: csharp

        int [] a = new int[100000000];
        a[a.Length-1] = 1;

        // シリアル処理
        var bySerial = a.Count(c => c == 1);
        
        // 並列処理
        var byParallel = a.AsParallel().Count(c => c == 1);

  AsSequential

    * aa

  AsUnordered

    * aa

  Average

    * aa

  Cast

    * シーケンスの個々のオブジェクトの型変換を行う
    * ボックス化/ボックス化解除も実行できる
    * ただし、変換できないオブジェクトがあるとそこで例外が発生して動作は停止する
    * 全てのシーケンスの要素が変換可能である必要がある
    * 変換できないオブジェクトを無視したいときはOfTypeメソッドを使う
    * 実はこのメソッドはCastという名前であるにも関わらずキャストを実行するわけではない
    * このメソッドで実行されるのは、参照変換とボックス化と解除変換だけである
    * 他の変換は実行できないので、サンプルソース中で示されている通り、intからlongへの変換は実行できない

      .. code-block:: csharp

        A[] a = { new B() };  
        foreach (var item in a.Cast<B>()) item.Hello();  
        
        object[] x = { 1, 2 };  
        foreach (var item in x.Cast<int>()) Console.Write("{item} ");  
        Console.WriteLine();  
        
        int[] b = { 1, 2, 3 }; 
        //var r = b.Cast<long>();   // ←できない  
        var r = b.Select(c => (long)c);   // ←できる  
        foreach (var item in r) Console.Write("{item} ");  
        Console.WriteLine();  
        
        class A { }  
        class B : A  
        {   
          public void Hello() => Console.WriteLine("Hello!");  
        }
        
        // 実行結果  
        // Hello!  
        // 1 2  
        // 1 2 3

  Chunk

    * Chunkメソッドを使用すると引数の値を個数として複数の配列に分割する
    * たとえば、10個の要素があるシーケンスにChunk(5)を実行すると、5個の要素を持つ配列2つに分割する
    * 配列の列挙オブジェクトを生成する
    * 最後の配列のみ、数が足りない場合は指定した数よりも小さくなるかもしれない
    * このメソッドは、分割結果を必ず配列の列挙オブジェクトとして返すので、分割する単位が大きいと効率が良くない
    * Span<T>構造体とそのSplitメソッドを使って分割する方が良いだろう

      .. code-block:: csharp

        IEnumerable<int> a = Enumerable.Range(0, 10);  
        IEnumerable<int[]> x = a.Chunk(4);  
        foreach (var item in x)  
        {  
          foreach (var item2 in item) Console.Write("{item2} ");  
          Console.WriteLine(); 
        }  
        
        // 実行結果  
        // 0 1 2 3  
        // 4 5 6 7
        // 8 9

  Concat

    * 2つのシーケンスを連結する（Enumerable.Concatの場合）
    * A.Concat(B).Concat(C).Concat(D).Concat(E)のように繰り返し連結しても良い
    * 追加するのがシーケンスではなく一つの要素ならAppendメソッドの方が良い
    * 要素100個の配列と要素200個の配列をConcatメソッドで連結しても、要素300個の配列が産まれるわけではない
    * あくまで、Concatメソッドは二つのシーケンスが連結されるという情報を追加するだけである
    * 要素300個の配列が欲しければToArrayメソッドを更に使う

      .. code-block:: csharp

        var a = Enumerable.Range(1,5).Concat(Enumerable.Range(1,4).Reverse()).Toarray();
        foreach(var item in a) Console.Write(item);

        // 出力 : 123454321

    * 2つの並列シーケンスを連結する（ParallelEnumerable.Concatの場合）

      .. code-block:: csharp

        private static IEnumerable<int> GetList1()
        {
            foreach(var item in Enumerable.Range(1,100)) yield return item;
        }
        private static IEnumerable<int> GetList2()
        {
            foreach(var item in Enumerable.Range(100,100)) yield return item;
        }
        static void Main(string[] args)
        {
            // どちらも同意
            // foreach (var item in GetList1().AsParallel().Concat(GetList2().AsParallel()))
            foreach(var item in ParallelEnumerable.Concat(GetList1().AsParallel(),GetList2().AsParallel()))
            {
                Console.Write("{0} ", item);

                // 出力（結果は実行の都度異なる）
                // 3 1 4 5 10 11 9 7 13 12 6 8 14 15 16 2 108 102 103 109 60 110 
                // 107 17 173 111 105 106 104 199 65 112 18 178 135 66 113 19 179 
                // 165 67 114 20 180 166 68 115 21 181 167 69 116 22 182 168 70 117 
                // 23 183 71 118 24 184 72 119 25 185 89 120 26 186 90 121 27 187 91 
                // 122 28 188 92 123 29 189 93 124 30 190 94 125 31 191 95 126 32 
                // 192 96 127 33 193 97 128 34 194 98 129 35 195 99 130 36 196 100 
                // 131 37 197 100 132 38 198 140 133 39 141 134 40 142 136 41 147 
                // 137 42 148 138 43 149 139 44 150 143 45 151 144 46 152 145 47 153 
                // 146 48 154 169 49 155 170 50 156 171 51 157 172 52 158 174 53 159 
                // 175 54 160 176 55 161 177 56 162 57 163 58 164 59 61 62 63 64 73 
                // 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 101
                
                // "ParallelEnumerable" を "Enumerable" に変えると以下の出力となる
                // その場合は、".AsParallel()"は不要
                // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 
                // 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 
                // 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 
                // 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 
                // 92 93 94 95 96 97 98 99 100 100 101 102 103 104 105 106 107 108 109 
                // 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 
                // 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 
                // 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 
                // 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 
                // 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 
                // 195 196 197 198 199
            }
        }

  Contains

    * 比較を行うカスタム機能を指定することも可能なので、特定のフィールドの値が特定の値の場合のみ含まれていると見なすような使い方もできる
    * その場合はIEqualityComparer<T>インターフェースを実装したオブジェクトを用意する

      .. code-block:: csharp

        using System.Diagnostics.CodeAnalysis;  
        
        Person[] persons = {   
          new Person("Jun",18),   
          new Person("Jinpei",20), 
          new Person("Ken",18),  
        };  
        
        Person Joe = new Person("Joe", 20);  
        
        var r = persons.Contains(Joe, new MyComparer()) ? "いる" : "いない";  
        Console.WriteLine("{Joe.Name}と同じ年齢の人は{r}");  
        
        record Person(string Name, int Age);  
        
        class MyComparer : IEqualityComparer<Person>  
        {   
          public bool Equals(Person? x, Person? y)   
          {   
            return x?.Age == y?.Age;   
          }   
          
          public int GetHashCode([DisallowNull] Person obj)   
          {   
            return obj.Age.GetHashCode();   
          }  
        }  
        
        // 実行結果  
        // Joeと同じ年齢の人はいる

  Count

    * シーケンスの要素数を返す
    * 条件を付加した場合は、その条件を満たす要素数を返す
    * null許容型の平均値の場合、null値は単純に無視される
    * シーケンスの値が全てnullの時、Averageメソッドはnullを返す

      .. code-block:: csharp

        Console.WriteLine("lの数は{0}個", "Hello".Count(c => c =='l'));

        // 出力 : lの数は2個

  DefaultIfEmpty

    * シーケンスが空の場合はデフォルト値のみを含むシーケンスを返す
    * 空ではない場合はシーケンスをそのまま返す
    * Max()メソッドのように空のシーケンスで使うと例外を起こしてしまう場合に、直前に挟むことで例外を回避することができる（ただしMaxの結果が0となることを許容できる場合）

  Distinct

    * シーケンスから重複する要素を取り除き、どの値も1つしか含まれないようにする
    * 引数にIEqualityComparer<T>インターフェースを実装した比較オブジェクトを渡すと比較をカスタマイズできる
    * たとえば、商品名が違っていてもID番号が同じなら【同じ】と見なして除去することもできる

  DistinctBy

    * Distinctメソッドと似ているが、等価を判定する値を選ぶキーセレクターを指定する点で異なっている

      .. code-block:: csharp

        Person[] p = {  
          new Person("Taro",new DateTime(2023,1,1)),  
          new Person("Taro",new DateTime(2023,1,2)),  
          new Person("Jiro",new DateTime(2023,1,3)),  
          new Person("Taro",new DateTime(2023,1,4)),  
          new Person("Saburo",new DateTime(2023,1,5)),  
        };   
        
        Console.WriteLine(string.Join(',',p.DistinctBy(c=>c.Name).Select(c=>c.Name)));  
        
        record Person(string Name, DateTime Time);  
        
        // 実行結果  
        // Taro,Jiro,Saburo

  ElementAt

    * シーケンスの指定インデックスの要素を取得する
    * 値の取得のみができる
    * シーケンスの列挙を前提とするので、速度は遅い
    * あまり使われない

  ElementAtOrDefault

    * ElementAt参照
    * 存在しない要素を指定した場合に例外ではなく型のデフォルト値を返すようにすることができる

  Empty

    * 空のシーケンスを取得する
    * 空のシーケンスはダミーの引数に便利である他、例のようにAppendメソッドやConcatメソッドで要素を追加するタネとして使うこともできる
    * 空の配列も使えるが、Emptyメソッドの方が空のシーケンスを作るという意図を明確に示すことができる

      .. code-block:: csharp

        var a = Enumerable.Empty<int>();  
        for (int i = 1; i <= 256; i *= 2) a = a.Append(i);  
        Console.WriteLine($"{string.Join(',',a)}");  
        
        // 実行結果  
        // 1,2,4,8,16,32,64,128,256

  Except

    * 2 つのシーケンスの差集合を生成する

  ExceptBy

    * キー セレクター関数を使用するだけでExceptと同じ機能

  First

    * シーケンスの最初の要素、または条件を満たす最初の1つを返す
    * 該当データがない場合は例外となる
    * シーケンスに目的のデータが確実にあるとわかっている場合は、FirstOrDefaultメソッドよりもこのメソッドの方がよい。
      バグによりシーケンスにデータがない場合に、例外ですぐにわかるため

      .. code-block:: csharp

        string[] a = {"a", "ab", "abc", "de"};

        // 引数に条件を入れる
        Console.WriteLine(a.First(c => c.Length == 2));

        // 出力 : ab

  FirstOrDefault

    * シーケンスの最初の要素、または条件を満たす最初の1つを返す
    * 該当データがない場合は型の既定値を返す、もしくは指定した値を返す

  ForAll

    * aa

  GroupBy

    * 引数で指定したキーセレクターで取得された値に従って要素の値をグループ分けする
    * キー値の一致判定はコードを指定することもできるので、柔軟に動作をカスタマイズできる
    * 結果は二重の列挙となる
    * キーの列挙と、個々のキーに属する要素の列挙である

      .. code-block:: csharp

        Person[] p =  
        {   
          new Person(1,"一之瀬"),   
          new Person(2,"二階堂"),   
          new Person(1,"一橋"),  
        };
        foreach (var item in p.GroupBy(c => c.Grade))  
        {
          Console.WriteLine("{0}年生グループ", item.Key);   
          foreach (var item2 in item) Console.WriteLine(item2.Name);  
        }  
        
        record Person(int Grade,string Name);  
        
        // 実行結果: 
        // 1年生グループ
        // 一之瀬  
        // 一橋  
        // 2年生グループ  
        // 二階堂


  GroupJoin

    *  シーケンスを2つ入力して新しいシーケンスを作り出す
    *  作成されたシーケンスは二重の列挙となる
    *  このメソッドの特徴はキーのセレクターが2つあること
    *  つまり、二つのシーケンスから別々の条件でキーを取得することもできる

      .. code-block:: csharp

        // 頭文字が同じ名前の組み合わせを姓リストと名リストから全て生成する
        // c => c[0]とd =>d[0]はどちらもキーのセレクターである
        string[] a = { "Anderson", "Brian", "Hanazono" };  
        string[] b = { "Alice", "Antonio", "Hanako" };  
        var q = a.GroupJoin(b, c => c[0], d => d[0], (x, e) => new { x, e });  
        
        foreach (var n in q)   
          foreach (var m in n.e)   C
            onsole.WriteLine("{m} {n.x}");  
            
        // 実行結果  
        // Alice Anderson  
        // Antonio Anderson  
        // Hanako Hanazono

  Intersect

    * aa

  Join

    * aa

  Last

    * シーケンスの最後の要素、または条件を満たす最後の1つを返す。該当データがない場合は例外となる
    * :term:`First` とほぼ同じ

  LastOrDefault

    * シーケンスの最後の要素、または条件を満たす最後の1つを返す。該当データがない場合は型の既定値を返す
    * :term:`FirstOrDefault` とほぼ同じ

  LongCount

    * aa

  Max

    * aa

  Min

    * aa

  OfType

    * aa

  OrderBy

    * シーケンスを昇順に並び替える
    * 実行しても、元の配列の順は変わらない
    * 一方、Array.Sort()は元の配列の順を変える
    * 複数の条件でソートする場合は :term:`ThenBy` を使用する

      .. code-block:: csharp

        int[] a = {2,1,3};
        
        foreach(var item in a.OrderBy(t => t)) Console.Write(item);
        // 出力 : 123

        Array.Sort(a);
        foreach(var item in a) Console.Write(item);
        // 出力 : 123


  OrderByDescending

    * シーケンスを降順に並び替える

  Range

    * aa

  Repeat

    * 同じ値が指定回数繰り返されるシーケンスを生成する

      .. code-block:: csharp

        var a = ParallelEnumerable.Repeat('2', 20);

        // 出力 : 22222222222222222222

  Reverse

    * シーケンスの順番を逆転させる

  Select

    * シーケンスを射影する

  SelectMany

    * https://yaspage.com/cs-linq-selectmany/
    * リストの中にあるリストを１つにまとめることができる（平坦化という）
    * 以下は上記URLの4例のうちの1例である

      .. code-block:: csharp

        // 基本的な使い方
        class Program
        {
            public static void Main()
            {
                // SampleDataクラスのリストの宣言と初期化
                List<SampleData> list = new List<SampleData> {
                    new SampleData { Name = "a", DataList = new List<int> { 1, 2, 3 } },
                    new SampleData { Name = "b", DataList = new List<int> { 4, 5, 6 } },
                    new SampleData { Name = "c", DataList = new List<int> { 7, 8, 9 } },
                };

                // SelectManyでリストの中のリストを１つにまとめたものを他の項目と組み合わせる
                var result = list.SelectMany(
                                      data => data.DataList,                                    // (1)
                    (data, DataList_value) => new { Name = data.Name, Value = DataList_value }  // (2)
                );
                // 結果を表示
                foreach (var d in result)
                {
                    Console.WriteLine("Name={d.Name}, Value={d.Value}");  // 要$
                }
            }
        }

        class SampleData
        {
            public string Name { get; set; }
            public List<int> DataList { get; set; }
        }

        // 出力
        // Name=a, Value=1
        // Name=a, Value=2
        // Name=a, Value=3
        // Name=b, Value=4
        // Name=b, Value=5
        // Name=b, Value=6
        // Name=c, Value=7
        // Name=c, Value=8
        // Name=c, Value=9

    * 2つのシーケンスを入力に持つクエリを実現するために使用される
    * 全ての組み合わせが生成される
    * 以下は掛け算の九九表の例
    * 上記の例と同じ引数2つの使い方であるが、(1)において、
      上記はlist内のDataListを平坦化したコレクションを使用しているのに対して、
      下記は別のコレクションを使用している点がおもしろい

      .. code-block:: csharp

        // 補足
        var list1 = Enumerable.Range(1,9);
        var list2 = Enumerable.Range(1,9);
        var a = list1
                .SelectMany(
                      x => list2,                         // (1) x:list1の要素
                  (x,y) => x + "X" + y + "=" + (x * y));  // (2) y:list2の要素     

  SequenceEqual

    * aa

  Single

    * 該当データが1つのみであることが保証される場合に使用する
    * 0個や2個以上の場合は例外が発生する

    .. code-block:: csharp

        a.Single(c => c.Id == 2)

  SingleOrDefault

    * 該当データない場合に既定値を返す
    * 2個以上の場合は例外が発生する
    * 他は :term:`Single` と同じ

    .. code-block:: csharp

        a.SingleOrDefault(c => c.Id == 2)

  Skip

    * aa

  SkipWhile

    * aa

  Sum

    * aa

  Take

    * aa

  TakeWhile

    * aa

  ThenBy

    *  :term:`OrderBy` メソッドでソートした結果に、さらに条件を追加してソートする
    *  OrderBy().ThenBy().ThenBy()...で条件をつなげていく

      .. code-block:: csharp

        int[] array = {-2, -1, 0, 1, 2};
        var query = array
                    .OrderByDescending(x => Math.Abs(x))  // 条件1
                    .ThenByDescending(x => x)             // 条件2
                    .Select(x => x);

    * 上記と同じ処理内容を、比較オブジェクトを使用して書くことも可能
    * 比較の条件が込み入ったときは、その方がスマートになることもある

      .. code-block:: csharp

        class Comparer : ICompare<int>
        {
          public int Compare(int x, int y)
          {
            int result = Math.Abs(x) - Math.Abs(y);
            if(result == 0) return x - y;
            return result;
          }
        }

        static void Main(string[] args)
        {
          int[] array = {-2, -1, 0, 1, 2};
          var query = array.OrderByDescending(x => x, new Compare());
        }

  ThenByDescending

    * 結果が降順となる以外、 :term:`ThenBy` メソッドと同じである

  ToArray

    * シーケンスから配列を作成する
    * 新規に配列を作成する（配列の複製）

    .. code-block:: csharp

        int a[] = {1,2,3};
        int b[] = a.ToArray();

        // この場合、a,bは別オブジェクトとなる
        // つまり、bはaを複製した配列である

  ToDictionary

    * aa

  ToList

    * aa

  ToLookup

    * aa

  Union

    * aa

  Where

    * aa

  WithCancellation

    * aa

  WithDegreeOfParallelism

    * aa

  WithExecutionMode

    * aa

  WithMergeOptions

    * aa

  Zip

    * aa
