====================
イベント、デリゲート
====================

トリガ、イベント、ハンドラ
==========================

* トリガとは、イベントを発行させるための外部動作のこと。例えば、マウスクリックなど
* トリガ -> イベント -> ハンドラ　の順に生じる
* マウスクリック -> クリックイベント -> クリックイベントハンドラ（実処理）

イベント
========

* EventHandler 型はデリゲート型である。
* よって、下記コードで event を削除し、handlerの登録を+=ではなく=とすると、デリゲート呼び出しになる。
* イベントハンドラは必ずvoid型であること
* 戻り値ありとなる場合は、デリゲート呼び出し（委譲メソッド）を検討すること

  .. code-block:: csharp

    class Sample
    {
        // イベント定義（デフォルトでイベントフックしておきたい場合）
        // デフォルトのイベントハンドラを登録しておけば、デバッグに便利
        public event EventHandler<CommandSentEventArgs> CommandSent 
            = (s, e) => System.Diagnostics.Debug.WriteLine("CommandSent");

        private void Send(List<byte> byteList)
        {
            CommandSent(this, new CommandSentEventArgs(byteList));
            
            // 以下でもよい？
            CommandSent?.Invoke(this, new CommandSentEventArgs(byteList));
        }
    }

    // イベント引数クラス
    public class CommandSentEventArgs : EventArgs
    {
        public List<byte> ByteList { get; private set; }

        public CommandSentEventArgs(List<byte> byteList)
        {
            this.ByteList = byteList;
        }
    }

    class Program
    {
        private string SendReceiveHistory = "";

        // イベントハンドラメソッド
        private void WriteSendHistory(object sender, CommandSentEventArgs e)
        {
            this.SendReceiveHistory += System.BitConverter.ToString(e.ByteList.ToArray());
        }

        void Main(string[] args)
        {
            var sample = new Sample();
            // イベントハンドラ登録
            sample.CommandSent += WriteSendHistory;

            var byteList = new List<byte>();
            // byteList.Add(・・); ・・・・
            sample.Send(byteList);
        }
    }

デリゲート
==========

* Action : 任意個の引数を取り、かつ、戻り値のないメソッドへのDelegate
* Func : 任意個の引数を取り、かつ、戻り値のあるメソッドへのDelegate
* Predicate : 任意個の引数を取り、かつ、戻り値の型がBooleanであるメソッドへのDelegate。つまり、Func<T,bool>などに相当 

デリゲート呼び出し
==================

  .. code-block:: csharp

    Func<int> func = () => 1;
    func += () => 2;            // 複数登録を防ぐことができない
    Console.WriteLine(func());  // 2が出力
                                // 複数登録の場合、最後に登録されたもののみが有効

ラムダ式
========

* "=>"" は"ゴーズ・トゥー"と読む
* 左辺のパラメータの書き方

  * 0個 : () => XXX
  * 1個 : s => XXX
  * 複数 : (a,b) => a.XX && b.xx

* 右辺が式のみの場合は return を書かなくてよい

  .. code-block:: csharp

    class Program
    {
        private static void b(Action sample)
        {
            sample();
        }
        static void Main(string[] args)
        {
            b(() => 
            {
               Console.WriteLine("I'm a method!");
            });
        }
    }

子イベントを親に透過
====================

透過させるのがベストの場合は以下でよいが、新たなイベントを作成して発火させる方法でもよい。

  .. code-block:: csharp

    this.dataGrid.AddHandler(DataGrid.MouseUpEvent, new MouseButtonEventHandler((sender,e)=> {/* ～～; */}), true);
