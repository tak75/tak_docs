=======
Dispose
=======

Dispose
=======

* Disposeにはマネージ/アンマネージのリソースの後処理を書く
* Disposeコール時にデストラクタがコールされるわけではない
* Disposeコール時は、そのオブジェクトへの参照が切られるだけである
* デストラクタがコールされるタイミングはGC任せであり、メモリが解放されるのはそのタイミングとなる
* マネージのリソースのみの場合は、Disposeもデストラクタも不要？（少なくとも、Task.Run()で走らせたスレッドはバックグラウンドスレッドなので、スレッドを保有するオブジェクトがGCに回収された時点で自動的にスレッドは停止する）

デストラクタ
============

* 通常は使用しない（理由:デストラクタを起動するのは1つのスレッドのみであり、そのスレッドの負荷となるため。また、単一スレッドであるため、デストラクタの処理中にハングアップした場合に、以降でデストラクタの処理ができなくなるため）
* アンマネージのリソースがある場合はデストラクタでDispose()をコールしておく（外部からDispose()がコールされなかった場合の保険）
* ただし、デストラクタはGC回収時にコールされるため、それまではオブジェクトへの参照も維持され、メモリも解放されない

メモリリークチェックの方法
==========================

コンストラクタとデストラクタでDebug.WriteLineしておき、デバッガ上でコールされているか確認する

.. code-block:: csharp

  #if MEMORY_LEAK_CHECK
      // コンストラクタ
      static int count = 0;
      XXXXX ()
      {
          System.Diagnostics.Debug.WriteLine("XXXXX Allocate {++count}"); // $必要
      }
  #endif
  #if MEMORY_LEAK_CHECK
      // デストラクタ
      ~ XXXXX ()
      {
          System.Diagnostics.Debug.WriteLine("XXXXX Free {--count}"); // $必要
      }
  #endif

